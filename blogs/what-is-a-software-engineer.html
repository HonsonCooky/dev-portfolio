<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="../assets/imgs/favicon.svg" rel="icon" type="image/svg+xml" />
    <title>Harrison Cook | What is a Software Engineer</title>
    <link rel="stylesheet" href="../assets/styles/minimal-style.css" />
  </head>
  <body>
    <a href="/blogs">Back</a>

    <header>
      <hgroup>
        <h1>[Draft] What is a "Software Engineer?"</h1>
        <p><b>Programming as a trade.</b></p>
        <div>
          <a href="/">Harrison Cook</a>
          :
          <time>2025-06-20</time>
        </div>
      </hgroup>
    </header>

    <hr />
    <br />

    <h1><u>The Problem</u></h1>
    <section id="opening-statement">
      <p>
        I'm increasingly frustrated by the state of discourse in programming communities. It feels like every
        conversation is a battle against a vague "it depends" - a convenient dismissal that often masks a fundamental
        lack of shared understanding. We're drowning in a relentless tide of new ideas and shiny tools, each shilled for
        internet brownie points, making learning feel pointless when the goalposts constantly shift without clear
        context. This isn't just noise; it's a symptom of a deeper issue. The reality is, "software engineering" and
        "software development" have been diverging for some time, and our industry hasn't yet fully acknowledge this
        critical distinction.
      </p>
    </section>

    <br />

    <h1><u>Axioms (Core Truths)</u></h1>
    <section id="axioms">
      <p>
        Let's establish a few "axioms" to make sure we're on the same page. If you accept these concepts as true, then
        the conclusions I draw should logically follow. However, if these axioms don't quite align with your own
        reality, then it's likely the conclusions derived from this framework will also diverge from your perspective.
      </p>
      <p>
        Both of these axioms are actually based on emergent human behaviors and patterns. While I'm presenting them
        pretty concisely here, each concept has a ton of extensive research behind it that I've omitted for brevity.
      </p>

      <h1>Shared Qualia:</h1>
      <p>
        <b>Qualia</b> (singular: <em>quale</em>) refers to those individual, subjective, conscious experiences - often
        described as the "what it is like" aspect of our mental states. Every person possesses a totally unique
        collection of qualia, and this inherent uniqueness begins with a simple, undeniable truth: no two individuals
        can occupy the exact same space at the exact same time. This fundamental physical reality means our experiences,
        and thus the "ingredients" we draw from for learning, are inherently distinct. Our brains naturally form
        weighted neural pathways, and these pathways truly shape our perception through these individual, unrepeatable
        experiences. This inherent neuroplasticity allows for constant learning, but it also strengthens established
        neural connections, making them quite resistant to change.
      </p>
      <p>
        However, while each person's overall "qualia landscape" is unique, we often find shared qualia in specific,
        smaller "subnets" of experience (where input&nbsp;&approx;&nbsp;output). These pockets of shared understanding
        enable empathy and mutual comprehension, forming the basis where certain ideas can "just make sense" without
        needing explicit depiction. Conversely, when individuals operate within vastly different conceptual frameworks,
        their subjective experiences of the same activity can become profoundly divergent, making it truly difficult to
        find common ground and often hindering progress.
      </p>

      <h1>The "Understanding" Continuum:</h1>
      <section>
        <p>
          Many mature knowledge-based disciplines naturally grow beyond one person's understanding, and they tend to
          evolve across a spectrum that can be outlined by three "interpretation" markers.
        </p>

        <p>
          <b>1. Theoretical:</b>
          First, we have the <em><b>Theoretical</b></em> interpretations. This is the entirely academic realm, where the
          foundational principles and core knowledge for some topic are established. This partition is about
          understanding the core "how" and "why" at the deepest level, often without immediate practical application in
          mind. Those deep in this field focus on if it's possible, rather than if it's <em>currently</em> possible.
        </p>

        <p>
          <b>2. Practical:</b>
          Next comes the <em><b>Practical</b></em> interpretations. Here, theory meets the real world with real
          constraints. This stage involves systematically taking foundational principles and combining them with a deep
          understanding of what's currently possible. It's about translating abstract "how" and "why" into the design
          and creation of real components, systems, and structures.
        </p>

        <p>
          <b>3. Abstract:</b>
          Finally, we arrive at <em><b>Abstract</b></em> interpretations. This stage builds on the outcomes of the
          applied theory to achieve large-scale results. It's about working with components, tools, and established
          practices to build complex systems efficiently, often completely abstracted away from the raw theoretical
          underpinnings or even the deep practical constraints.
        </p>
      </section>

      <h1>The World We've Created:</h1>
      <p>
        To summarize, I've identified three markers or levels of interpretation for any sufficiently large
        knowledge-based subject, and I believe we can definitely share these interpretations.
      </p>
    </section>

    <br />

    <h1><u>To The Real World</u></h1>
    <section id="idea">
      <p>
        Herein lies the core concept I'm trying to highlight. Programmers now find ourselves - like many before us - on
        a knowledge spectrum that has grown considerably large. "Mastering" the entire spectrum is frankly beyond human
        capabilities, as it requires deep understanding across often conflicting mediums. That's precisely why in other
        fields, we've divided and conquered, breaking things into distinct disciplines so people can genuinely succeed
        within their area of focus.
      </p>

      <h1>An Established Example:</h1>
      <p>
        Let's look at a well-established knowledge-based field: electricity. Its <em><b>Theoretical</b></em> knowledge
        is rooted in Electricity and Magnetism Physics. These concepts are then translated into
        <em><b>Practical</b></em> knowledge by Electrical Engineers, who develop and research real-world electrical
        systems and products. Finally, the installation, maintenance, and repair of these systems and products
        constitute the <em><b>Abstract</b></em> knowledge applied by Electricians. Each occupation along this continuum
        plays a crucial role in enabling the wider population to access the benefits of electricity in our homes.
      </p>

      <h1>Translating To Programmers:</h1>
      <p>
        Let's now translate this idea to the world of programming, mirroring our electricity continuum and its inherent
        qualia distinctions.
      </p>
      <p>
        Here, <em>Computer Science</em> represents the <em><b>Theoretical</b></em> knowledge, delving into the
        foundational algorithms, data structures, and computational principles that underpin all software. The
        <em>Software Engineer</em> embodies <em><b>Practical</b></em> knowledge, systematically designing, developing,
        and rigorously testing software solutions, effectively translating theoretical concepts into functional
        codebases and systems. Finally, the <em>Software Developer</em> operates with
        <em><b>Abstract</b></em> knowledge, focusing on the hands-on implementation, debugging, and maintenance of
        specific applications and features. Modern programming languages and advanced IDEs significantly empower this
        role. Like the Electrician, their strength lies in the tangible realization and ongoing care of the system,
        often applying intuitive problem-solving to make the code work effectively in diverse, real-world scenarios.
        This enables them to build entire full-stack applications, a capability that has become increasingly accessible
        and prevalent over time.
      </p>
      <p>
        And so, that's the core idea. It's a perspective I believe isn't as widely recognized as it should be, yet it
        carries profound implications when we consider its ramifications. Next, I'll dive into what this distinction
        means for common disagreements and frictions within the programming world. If you find yourself strongly
        disagreeing at this point, that's perfectly understandable. However, I encourage you to continue to the examples
        in the following sections; perhaps these interpretations will shed light on why we observe certain phenomena
        within our professional communities.
      </p>
      <img src="./imgs/theory-abstract-scale.png" alt="theory-to-abstract.png" />
    </section>

    <br />

    <h1><u>Emergent Example | Programming Languages</u></h1>
    <section id="examples-programming">
      <p>
        Just as different trades require specialized tools, various programming languages naturally align with distinct
        "qualia" of programmers. This alignment often explains why certain languages provoke such strong opinions or
        find success in particular domains, often independent of their inherent "goodness."
      </p>

      <p>
        Consider <b>JavaScript</b>, a language frequently mocked for its inconsistencies and quirks, yet undeniably
        triumphant in its widespread adoption. While its peculiarities - like the sometimes baffling behavior of type
        coercion - might chafe those with a purist's eye, its remarkable simplicity for rapidly achieving functional
        results is its superpower. For the <em>Software Developer</em>, whose strength lies in
        <em><b>Abstract</b></em> knowledge and just making things work, JavaScript is a near-perfect fit (as it seems).
        The "qualia" isn't focused on the intricate details of <code>Array.prototype.sort</code>'s default
        implementation, but on quickly integrating a solution that delivers the correct output. Its omnipresence, even
        extending beyond the browser to server-side environments, is a testament to its effectiveness as an
        <em><b>Abstract</b></em> tool for agile development, significantly aided by powerful modern frameworks and build
        tools, rather than a paragon of theoretical elegance.
      </p>

      <p>
        At the other end of this spectrum lies <b>Haskell</b>, often referred to as a "white paper" language due to its
        profound connection to Lambda Calculus and theoretical "Computer Science." Its design principles prioritize
        mathematical rigor, immutability, and formal verification, making it a natural fit for academics engaged in deep
        <em><b>Theoretical</b></em> reasoning and exploring the foundational principles of computation. Directly
        contrasting this are languages like <b>Assembly</b> and <b>C</b>, which firmly reside in the realm of the
        "Software Engineer." These tools demand an intimate, granular understanding of how hardware operates, often
        requiring significant time and effort to truly grasp the system's inner workings. For the engineer (whose qualia
        is rooted in <em><b>Practical</b></em> knowledge and the systematic translation of theoretical concepts into
        functional code), being as close to the machine's implementation as possible isn't merely helpful - it's
        absolutely essential for their role in meticulously crafting how physical machines execute commands.
      </p>

      <p>
        <b>Python</b> offers a fascinating case study in versatility, demonstrating its utility across multiple points
        on our continuum. Its highly readable syntax, often likened to "pseudocode," makes it an exceptional tool for
        rapid prototyping and abstract problem-solving, aligning perfectly with the <em>Software Developer's</em> focus
        on efficient implementation and tangible outcomes. Its extensive libraries and frameworks further enhance its
        ability to achieve full-stack capabilities with remarkable ease. Yet, this same clarity and simplicity
        paradoxically make it a powerful vehicle for quickly demonstrating proofs and validating theoretical concepts,
        finding a surprising and significant home in academic research ("Computer Science").
      </p>

      <p>
        <b>C#</b>, <b>C++</b>, and <b>Rust</b> sit in a middle ground between Engineers and Developers. For Software
        Engineers, their abstractions can make them slow to pick up, as understanding how things work "under the hood"
        becomes harder. For Software Developers, these languages work well for building applications quickly, especially
        with modern IDEs. However, if something goes wrong and a deeper understanding of computer operations is needed,
        developers might find themselves stuck, searching for answers beyond the abstract layer. Ultimately, these
        languages highlight the spectrum between engineers and developers. Their effective use, and the quality of the
        work, depends on how well the user's understanding aligns with the level of abstraction these tools provide.
      </p>

      <h3>Programming Language Qualia</h3>
      <p>
        These varied examples beautifully illustrate how the design philosophies and practical applications of different
        programming languages inherently align with the distinct "qualia" and knowledge bases of
        <em><b>Theoretical, Practical</b></em> and <em><b>Abstract</b></em> programming roles. My framework, I believe,
        offers a compelling explanation for many common frictions and misunderstandings that permeate our diverse
        professional communities - an explanation that often feels elusive in current discussions.
      </p>
    </section>

    <br />

    <h1>
      <u>Emergent Example | Fear&nbsp;of Artificial&nbsp;Intelligence (Large&nbsp;Language&nbsp;Models - 2025)</u>
    </h1>
    <section id="examples-artificial-intelligence">
      <p>
        The rapid ascent of Artificial Intelligence, particularly Large Language Models (LLMs) in 2025, has sparked
        considerable anxiety within the programming community regarding job displacement. However, viewed through the
        lens of our "Understanding Continuum," the perceived threat of AI tools "removing" someone's job is almost
        entirely dependent on where that job lands on the spectrum.
      </p>
      <p>
        Those operating within Theoretical and Practical interpretations exist in a world of building what hasn't been
        built before, pushing the boundaries of computational understanding and system design. This space, fundamentally
        about novel creation and deep problem-solving, is not where AI currently excels. AI's strength lies in pattern
        recognition and efficient execution of known tasks, not in originating entirely new paradigms or solving truly
        unprecedented challenges.
      </p>
      <p>
        Conversely, for the Software Developer operating primarily at the Abstract level, AI is rapidly becoming the
        next iteration of tooling, much like how Integrated Development Environments (IDEs) with features like
        autocomplete and sophisticated refactoring made building large-scale projects feasible. Consider: how many jobs
        were truly taken because JetBrains built IntelliJ, or because Git simplified version control? The conflict isn't
        new; it's a recurring pattern where abstraction layers evolve, making certain tasks more efficient.
      </p>
      <p>
        It's crucial to be clear: AI isn't "magic." These are powerful tools designed to assist, and their helpfulness
        is currently inversely proportional to the level of abstraction. The more abstract the task - the more it
        involves combining existing components, boilerplate generation, debugging common patterns, or translating
        high-level intent into functional code - the heavier AI's helpfulness becomes. AI assists in automating the
        abstract realization and ongoing care of systems, allowing Software Developers to be even more productive in
        building full-stack applications with remarkable speed. This augmentation, rather than replacement, frees up
        cognitive load for developers to focus on higher-level problem-solving and feature development, solidifying
        their role as the skilled "Electricians" of the software world.
      </p>
    </section>

    <br />

    <h1><u>Emergent Example | Framework Developers</u></h1>
    <section id="examples-framework-devs">
      <p>
        Another telling emergent example of our industry's unacknowledged specialization is the proliferation of
        hyper-specific titles, such as "React Developer." In the world we've created, Software Developers increasingly
        feel the need to distinguish themselves amidst a growing sea of individuals holding the same generic title.
        Identifying oneself primarily by the specific tools or frameworks one can use - be it React, Angular, Vue, or a
        particular cloud platform - is a symptom of this inability to formally establish clear differences between
        software engineering and software development.
      </p>
      <p>
        If a "Software Engineer" is primarily concerned with the deep theoretical underpinnings and the practical design
        of systems, their identity isn't defined by a transient framework but by their understanding of foundational
        principles. An Electrical Engineer doesn't call themselves a "Siemens PLC Engineer"; they are an Electrical
        Engineer who uses Siemens PLCs. Similarly, a Software Engineer might specialize in distributed systems or
        compiler design, and the tools they use are secondary to their domain of expertise.
      </p>
      <p>
        However, for the Software Developer, whose strength lies in the abstract application of established practices to
        build complex systems efficiently, proficiency with specific, powerful frameworks like React is paramount to
        their daily work and market value. Their "qualia" is profoundly shaped by the nuances of these tools, making it
        logical for them to identify with the ecosystem in which they operate. The "React Developer" phenomenon,
        therefore, is not a failure of individual specialization, but rather a natural and necessary response by
        Software Developers to signal their concrete, immediately applicable skill set within a profession that
        desperately needs more refined vocational pathways. It highlights the market's organic push towards recognizing
        the value of expertise at the Abstract level, even if our formal titles haven't caught up.
      </p>
    </section>

    <br />

    <h1><u>Education</u></h1>
    <section id="education">
      <p>
        <b>Foreword</b>: Before diving into this section, it's really important to acknowledge that discussions around
        education and professional pathways can be deeply personal and, frankly, contentious. We're venturing into
        territory where existing paradigms meet my theoretical framework. The real-world examples I'm about to explore
        are absolutely not meant to devalue anyone's current journey or achievements. Rather, the aim is to shed light
        on phenomena that often go unexplained within our industry. Implicit in this discussion is a vision for an ideal
        world - one where becoming a highly competent <em>Software Developer</em> doesn't necessarily necessitate
        hundreds of thousands of dollars in student debt, and where educational pathways are more clearly aligned with
        the specific "qualia" and <b>knowledge</b> required for each role. This section seeks to provide a fresh
        perspective, not to dictate a single, rigid path, but to open a dialogue about how we can better educate and
        empower all programmers.
      </p>
      <br />
      <p>
        Understanding how our qualia are formed is crucial to discussing education. As we agreed in our axioms, brains
        naturally build weighted neural pathways, making established perspectives pretty resistant to change. Reshaping
        this qualia is a slow, methodical process that requires consistent effort (the "by rote" method). Alternatively,
        it can be forced with more rapid transformation (usually this is from "trauma" - more to explore here, but for
        now, this is our axiom). Intentional education plays a critical role in aligning or expanding our individual
        qualia, allowing us to perceive and interact with complex domains in new ways. This is particularly evident when
        we consider how individuals acquire the distinct knowledge bases required for <em><b>Theoretical</b></em> ,
        <em><b>Practical</b></em> , and <em><b>Abstract</b></em> programming.
      </p>
      <p>
        A common observation within programming circles is the celebrated "self-taught Software Engineer." Often, when
        people refer to these individuals, they are, by my framework, speaking of highly talented
        <em>Software Developers</em>. These are indeed brilliant minds, capable of incredible feats of creation and
        problem-solving. However, their foundational knowledge, particularly concerning the deeper "how" and "why" of
        computing, may often be less comprehensive. While such a developer might have dedicated 10,000 hours to
        mastering C# and building intricate applications in the cloud - often leveraging powerful frameworks and IDEs to
        do so - they might not be able to articulate precisely how their high-level code translates into the granular
        instructions a computer executes. Their learning, by its nature, has occurred primarily at the
        <em><b>Abstract</b></em> level, focusing on applying existing components and patterns rather than dissecting
        their underlying mechanisms.
      </p>
      <p>
        This brings me to the distinct educational demands of <em>Computer Science</em> and
        <em>Software Engineering</em>. These fields delve into theoretical principles and practical system design that
        aren't just intuitively discovered or naturally occurring. They represent decades of rigorous development by
        some of the greatest mathematical and logical minds. It is profoundly unlikely that any individual, through
        sheer self-application alone, could independently re-derive or fully internalize the breadth and depth of
        knowledge encompassing topics like advanced algorithms, data structures, compiler design, or operating system
        principles. These are structured disciplines, built on cumulative, non-obvious insights that necessitate a
        formal, guided journey of discovery and rigorous critical thinking to truly grasp.
      </p>
      <p>
        This formal journey, particularly within a university setting, often involves a significant degree of
        intellectual stress. While discomforting, this stress is a vital catalyst for neuroplasticity; without it, the
        brain simply has less impetus to dismantle or significantly modify its existing worldview. Those who navigate
        this rigorous "ringer" of brain reshaping emerge with a fundamentally different way of perceiving and
        interacting with the world. They possess a <em><b>Practical</b></em> or <em><b>Theoretical</b></em> qualia that
        enables them to approach problems from a foundational perspective, often invisible to those whose experiences
        have primarily been at a higher level of abstraction. It's also something I find quite harmful for individuals
        with "Software Engineering" oriented qualia to be constantly told their inability to "just do" or quickly build
        full-stack applications with abstract tools is a personal failure. Their expertise truly lies in a different,
        but equally vital, area. <em>Software Development</em>, on the other hand, is much more accessible through
        self-study and focused application. Learning to build a web application over a weekend, for instance, is
        entirely feasible because it primarily involves acquiring and applying abstract knowledge - learning specific
        syntax, frameworks, and patterns - without inherently demanding a complete re-wiring of one's fundamental
        conceptual understanding.
      </p>
      <p>
        Ultimately, understanding these distinct educational pathways is key to appreciating the diverse strengths and
        perspectives within our programming community. It helps explain why different learning environments cultivate
        different types of qualia, and in turn, why certain roles are best suited to specific approaches of knowledge
        acquisition. Perhaps by recognizing these distinct needs, we can foster a future where
        <em>Software Development</em>
        truly emerges as a recognized trade, akin to that of an Electrician. This could empower countless individuals to
        gain industry-relevant skills without the immense financial burden or the perceived need to master theoretical
        concepts they may never directly apply in their daily work - addressing the common frustration of those with
        engineering degrees who feel over-qualified for much of the industry's developer work.
      </p>
      <p>
        It bears repeating: this discussion on education is not a pronouncement on prestige or a judgment of individual
        merit. Rather, it's an exploration of <b>alignment</b>. The most effective and fulfilling educational journeys
        are those that cultivate the specific qualia and knowledge base one is truly <em>driven</em> to master. In my
        own experience, my formal education, while rigorous and invaluable, often feels somewhat decoupled from the
        daily realities of my professional role. This isn't to say my education didn't prepare me for the world;
        instead, it highlights that the role I often find myself in may not precisely align with the theoretical and
        practical foundations I deeply engaged with. This distinction also has a critical implication for how we shape
        future learning: it is vital that we preserve the rigorous, foundational education of Software Engineering - the
        deep dive into theoretical principles and systemic design. Simultaneously, we must officially recognize and
        embrace Software Development education, mirroring the effectiveness we already see in focused programs and
        bootcamps, which often leverage the power of modern tools. When learning is directed by genuine purpose, it
        sharpens one's abilities, transforming them into a formidable force within a particular realm of software
        creation, irrespective of traditional labels or external validation.
      </p>
    </section>

    <br />

    <h1><u>Final Thoughts</u></h1>
    <section id="finale">
      <p>
        The journey through these concepts - Shared Qualia and the Understanding Continuum - reveals a crucial truth:
        the landscape of programming has matured far beyond a single, monolithic definition. What I've explored isn't
        about rigid labels or creating hierarchies; it's about fostering a deeper, more empathetic understanding of the
        distinct experiences and expertise that drive our industry forward. The "it depends" reflex, so prevalent in our
        daily discussions, often stems not from a lack of definitive answers, but from a fundamental divergence in how
        we perceive and interact with the very fabric of software, heavily influenced by the abstraction provided by
        modern tools.
      </p>
      <p>
        Our industry, much like other established disciplines that have grown to immense scale, is naturally
        specializing. This evolution is a sign of our collective sophistication, not a limitation. It means recognizing
        that while all programmers contribute to the grand endeavor of building technology, their qualia and the
        knowledge bases they operate within can be profoundly different. It's important to note that I think a lot of
        people currently operate somewhere along the spectrum between a Software Engineer and a Software Developer,
        blending aspects of both roles, and that's perfectly okay. This proposed framework, therefore, isn't an attempt
        to segment, but to illuminate, allowing us to appreciate the unique strengths each role brings to the table, and
        to avoid the harmful notion that one's specialized expertise makes them deficient in another area.
      </p>
      <p>
        Ultimately, by embracing these distinctions, we can bridge the often-unseen gaps that lead to friction and
        misunderstanding. Imagine a future where educational paths align more clearly with individual aptitudes and
        career aspirations, where job descriptions accurately reflect required expertise, and where teams collaborate
        with a clearer understanding of each other's inherent strengths. This isn't just about clearer communication;
        it's about building a more cohesive, efficient, and ultimately, more innovative software community, where every
        mind can truly flourish in its chosen domain.
      </p>
    </section>
  </body>
</html>
