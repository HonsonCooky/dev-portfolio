<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="../assets/imgs/favicon.svg" rel="icon" type="image/svg+xml" />
    <title>Harrison Cook | What is a Software Engineer</title>
    <link rel="stylesheet" href="../assets/styles/minimal-style.css" />
  </head>
  <body>
    <a href="/blogs">Back</a>

    <header>
      <hgroup>
        <h1>[Draft] What is a "Software Engineer"? <br /></h1>
        <p><b>Another Classic Broad Brush Problem</b></p>
        <div>
          <a href="/">Harrison Cook</a>
          :
          <time>2025-06-20</time>
        </div>
      </hgroup>
    </header>

    <br />
    <hr />
    <br />

    <section id="opening-statement">
      <h1>&#9888; The Problem:</h1>
      <p>
        I've experienced a disconnect growing in the tech world. While <q>software engineer</q> and
        <q>software developer</q> are often used synonymously, I argue that this conflation ignores a significant
        evolution in our industry. Modern developer tools and commercial expectations have fundamentally reshaped the
        work, creating a clear need to differentiate between the theoretical, the practical, and the abstracted layers
        of software creation.
      </p>
      <p>
        Let's draw a parallel to how another field has evolved. In the electrical world, the foundation is established
        in Electrical Physics, providing the pure theory and fundamental knowledge of electricity and magnetism. This
        then moves to Electrical Engineering, where that theory is practically applied, acknowledging and working within
        real-world limitations. Finally, the Electrician steps in, operating at an abstracted level, expertly handling
        larger implementations without needing to understand the deepest underlying mechanics. In my view, our industry
        mirrors this progression: Computer Science is our theoretical core, deeply grounded in mathematics, and Software
        Engineering bridges this theory with practice, demanding a robust understanding of digital architectures and
        hardware interactions. However, we are missing that finally role - and I think it has been prevalent for some
        time.
      </p>
      <p>
        Software Development: This role often operates at an abstracted level, where the intricacies of how code works
        beneath the surface, or its fundamental mathematical underpinnings, are largely hidden by powerful developer
        tools: IDEs and high-level frameworks. The focus shifts to efficient assembly and integration, often without the
        need for low-level understanding. I think it's crucial to acknowledge these diverging paths, and pave the way
        for a more focused and flourishing software landscape, free from unnecessary friction.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section id="qualia">
      <h1>&#129504; Qualia:</h1>
      <p>
        <b>Qualia</b> (singular: <b>quale</b>) refers to the individual, subjective, conscious experiences. It's often
        described as the <q>what it is like</q> aspect of mental states.
      </p>
      <p></p>

      <br />

      <p>
        Our brains are remarkably adaptable organs, constantly forming and reforming connections based on new
        experiences and information. This inherent neuroplasticity means we are always capable of learning and evolving.
        However, the very mechanisms that allow for this change also lead to the reinforcement of established ideas; the
        more frequently a neural pathway is activated, the stronger and more resistant to alteration it becomes. While
        each of us as a whole possesses a unique set of experiences and perceptions (qualia), we can also share common
        subsets (subnets) of qualia. This shared foundation of qualia allows for empathy (unlike sympathy) and mutual
        understanding, and it is upon this common ground that we can explore the distinct, yet interconnected, modes of
        thinking that define the programming spectrum.
      </p>
      <p>
        Ultimately, if shared qualia allows for empathy and mutual understanding, the divergence in experiences and
        reinforced neural pathways can then create a fundamental challenge. When one person's world is deeply rooted in
        the mathematical underpinnings and hardware interactions of code, and another's is largely confined to the
        high-level abstractions of an IDE and keywords of some language, subjective experiences of
        <q>programming</q> become profoundly different. It's this very divergence in perception that I believe makes it
        incredibly difficult for <q>software engineers</q> to find common ground around what should be known, leading to
        misunderstandings and misplaced talents that hinder progress.
      </p>
      <p>
        It's also crucial to acknowledge that, different ways of thinking and operating are not a measure of importance.
        Just like Electrical Engineers and Electricians rely on each other - entire industries would fail without both
        perspectives - the various roles in software are equally vital and interdependent. No single role is inherently
        superior; they simply fulfill different, yet essential, functions.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section id="three">
      <h1>&#8731; The Rule Of Three</h1>
      <p>
        Many mature disciplines naturally evolve across a spectrum of knowledge that can be marked by three various
        specializations.
      </p>

      <h3>1. Theoretical:</h3>
      <p>
        First, we have the <b>Theoretical</b> knowledge base. This is the entirely academic realm, where the
        foundational principles and knowledge for some topic are established. This knowledge partition is about
        understanding the core "how" and "why" at the deepest level, often without immediate practical application in
        mind. In the software field, theoretical thinkers may be focused on algorithms, data structures, computational
        complexity, and the mathematical logic behind how computers work.
      </p>

      <h3>2. Practical:</h3>
      <p>
        Next comes the <b>Practical</b> knowledge base. Here, theory meets the real world, applying those foundational
        principles to solve concrete problems and design functional systems. This knowledge base relies on an
        understanding of existing components and their interplay. For the software realm, your focus would be to
        understand the concepts of computer science and apply them to real world software systems within practical
        constraints - likely considering energy, time and space budgets.
      </p>

      <h3>3. Abstract:</h3>
      <p>
        Finally, we arrive at the <b>Abstract</b> thinking. This stage builds on the outcomes of applied theory to
        achieve large-scale results. It's about working with ready-made components, tools, and established patterns to
        build complex systems efficiently, often abstracted away from the raw theoretical underpinnings or even the deep
        practical constraints of individual components. In software terms, this abstracted level, focusing on assembling
        and integrating high-level frameworks, libraries, and APIs to build complex applications. Their day-to-day work
        often doesn't require a deep understanding of the underlying mathematical proofs or the intricate hardware
        interactions. Instead, their expertise lies in efficiently combining existing, pre-built solutions to deliver
        large-scale features and products.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section>
      <h1>&#9883; Tying It All Together:</h1>
      <p>
        Herein lies the core concept that I'm trying to highlight. We find ourselves - like many before - on a knowledge
        spectrum, which has grown considerably large. Mastering the entire knowledge spectrum at a deep level is usually
        beyond human capability. That's why we divide and conquer, breaking it into disciplines so people can genuinely
        succeed within their area of focus. How I would outline the software knowledge spectrum is such (given with
        examples from other spectrums).
      </p>
      <ul>
        <li>Theoretical: Computer Science, Electrical Physics, Chemistry, Material Science</li>
        <li>Practical: Software Engineer, Electrical Engineer, Chemical Engineer, Architect</li>
        <li>Abstract: Software Developer, Electrician, Chemist, Builder</li>
      </ul>
    </section>

    <div style="height: 30vh"></div>
    <p>... [more to come]</p>
  </body>
</html>
