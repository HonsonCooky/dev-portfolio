<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="../assets/imgs/favicon.svg" rel="icon" type="image/svg+xml" />
    <title>Harrison Cook | What is a Software Engineer</title>
    <link rel="stylesheet" href="../assets/styles/minimal-style.css" />
  </head>
  <body>
    <header>
      <hgroup>
        <h1>What is a "Software Engineer"? <br /></h1>
        <p><b>Another Classic Broad Brush Problem</b></p>
        <div>
          <a href="/">Harrison Cook</a>
          :
          <time>2025-06-20</time>
        </div>
        <br />
      </hgroup>
    </header>

    <section id="warning">
      <p>
        <b>Content warning:</b> This post delves into topics that might challenge your existing world views. If you're
        in no mood to wander the realm of the philosophical, you will want to come back at another time.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section id="opening-statement">
      <h1>&#9888; The Problem:</h1>
      <p>
        I've experienced a disconnect growing in the tech world. While <q>software engineer</q> and
        <q>software developer</q> are often used synonymously, I argue that this conflation ignores a significant
        evolution in our industry. Modern developer tools and commercial expectations have fundamentally reshaped the
        work, creating a clear need to differentiate between the theoretical, the practical, and the abstracted layers
        of software creation.
      </p>
      <p>
        Let's draw a parallel to how another field has evolved. In the electrical world, the foundation is established
        in Electrical Physics, providing the pure theory and fundamental knowledge of electricity and magnetism. This
        then moves to Electrical Engineering, where that theory is practically applied, acknowledging and working within
        real-world limitations. Finally, the Electrician steps in, operating at an abstracted level, expertly handling
        larger implementations without needing to understand the deepest underlying mechanics. In my view, our industry
        mirrors this progression: Computer Science is our theoretical core, deeply grounded in mathematics, and Software
        Engineering bridges this theory with practice, demanding a robust understanding of digital architectures and
        hardware interactions.
      </p>
      <p>
        However, a distinct and prevalent role has emerged: Software Development. This role often operates at an
        abstracted level, where the intricacies of how code works beneath the surface, or its fundamental mathematical
        underpinnings, are largely hidden by powerful developer tools: IDEs and high-level frameworks. The focus shifts
        to efficient assembly and integration, often without the need for low-level understanding. This post will
        explore why it's crucial to acknowledge these diverging paths, and how doing so can pave the way for a more
        focused and flourishing software landscape, free from unnecessary friction.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section id="qualia">
      <h1>&#129504; Qualia:</h1>
      <p>
        To begin our exploration, it's essential that we establish a shared understanding of certain theoretical
        constructs regarding the nature of reality. For our purposes, we don't need to delve into the underlying
        mechanisms or ultimate truths; rather, we only need to agree upon the existence and observable characteristics
        of emergent phenomena; that being:
      </p>
      <p>
        Our brains are remarkably adaptable organs, constantly forming and reforming connections based on new
        experiences and information. This inherent neuroplasticity means we are always capable of learning and evolving.
        However, the very mechanisms that allow for this change also lead to the reinforcement of established ideas; the
        more frequently a neural pathway is activated, the stronger and more resistant to alteration it becomes. While
        each of us possesses a unique set of experiences and perceptions, we can also share common subjective
        experiences, or qualia. This shared foundation of qualia allows for empathy (unlike sympathy) and mutual
        understanding, and it is upon this common ground that we can explore the distinct, yet interconnected, modes of
        thinking that define the programming spectrum.
      </p>
      <p>
        Ultimately, while the capacity for shared qualia allows for empathy and a degree of mutual understanding, the
        sheer divergence in daily experiences and reinforced neural pathways creates a fundamental challenge. When one
        person's world is deeply rooted in the mathematical underpinnings and hardware interactions of code, and
        another's is largely confined to the high-level abstractions of an IDE, their subjective experiences of
        <q>programming</q> become profoundly different. It's this very divergence in perception that I believe makes it
        incredibly difficult for aforementioned <q>software engineers</q> to find common ground, leading to
        misunderstanding and friction that hinders progress.
      </p>
      <p>
        It's crucial to understand that these different ways of thinking aren't about who's more important. Just like
        Electrical Engineers and Electricians rely on each other - the entire industry would fail without both - the
        various roles in software are equally vital and interdependent. No single role is inherently superior; they
        simply fulfill different, yet essential, functions.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section id="three">
      <h1>&#8731; The Rule Of Three</h1>
      <p>
        Every mature discipline, I believe, naturally evolves across a fundamental spectrum, a <q>rule of three</q> that
        clarifies its various specializations.
      </p>

      <h3>1. Theory:</h3>
      <p>
        First, we have <b>Theory</b>. This is the entirely academic realm, where the foundational principles and pure
        knowledge are established. This stage is about understanding the core "how" and "why" at the deepest level,
        often without immediate practical application in mind. In the software field, Computer Science perfectly
        embodies this theoretical stage. It's focused on algorithms, data structures, computational complexity, and the
        mathematical logic behind how computers work. A computer scientist might develop new sorting algorithms, prove
        the limits of computation, or design novel cryptographic methods, all within a highly academic and often
        abstract framework.
      </p>

      <h3>2. Practical:</h3>
      <p>
        Next comes <b>Practical</b>. This stage is where theory meets the real world. It's about applying those
        foundational principles to solve concrete problems and design functional systems, often with an understanding of
        real-world limitations and resources. This is the domain of Engineering or Architecture, translating theory into
        reality, ensuring real-world attributes are accounted for. Here, knowledge of existing components and their
        interplay is crucial. For software, this practical stage is represented by Software Engineering. A
        <q>Software Engineer</q> takes the theoretical concepts of computer science and applies them to build robust,
        scalable, and maintainable software systems within practical constraints. They understand how different
        components interact, how to design for reliability, and how their code will operate on specific hardware,
        bridging the gap between abstract theory and tangible application.
      </p>

      <h3>3. Abstract:</h3>
      <p>
        Finally, we arrive at <b>Abstract</b>. This stage leverages the established outcomes of applied theory to
        achieve large-scale operations. It's about working with ready-made components, tools, and established patterns
        to build complex systems efficiently, often abstracted away from the raw theoretical underpinnings or even the
        deep practical constraints of individual components. This brings us to <q>Software Development</q>. A
        <q>Software Developer</q> typically operates at this abstracted level, focusing on assembling and integrating
        high-level frameworks, libraries, and APIs using powerful IDEs. While they build complex applications, their
        day-to-day work often doesn't require a deep understanding of the underlying mathematical proofs or the
        intricate hardware interactions. Instead, their expertise lies in efficiently combining existing, pre-built
        solutions to deliver large-scale features and products.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section>
      <h1>The Spectrum:</h1>
      <p>
        With the established framework above, we now can address the edge cases that might have people screaming at
        their monitor about why I'm wrong. This section will tie back into this idea of <q>qualia</q>, and explain why
        <q>Bob from work is the best Software Engineer, but never had formal training</q>.
      </p>
    </section>

    <div style="height: 30vh"></div>
  </body>
</html>
