<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="../assets/imgs/favicon.svg" rel="icon" type="image/svg+xml" />
    <title>Harrison Cook | What is a Software Engineer</title>
    <link rel="stylesheet" href="../assets/styles/minimal-style.css" />
  </head>
  <body>
    <a href="/blogs">Back</a>

    <header>
      <hgroup>
        <h1>[Draft] What is a "Software Engineer?"</h1>
        <p><b>Programming as a trade.</b></p>
        <div>
          <a href="/">Harrison Cook</a>
          :
          <time>2025-06-20</time>
        </div>
      </hgroup>
    </header>

    <br />
    <hr />
    <br />

    <section id="opening-statement">
      <h1><u>The Problem</u></h1>
      <p>
        I've experienced a growing disconnect across programming communities; Every new idea or concept only works when
        prefaced with <q>it depends</q>. While <q>software engineer</q> and <q>software developer</q> are often used
        synonymously, I argue that this conflation ignores a significant evolution in our industry. Modern programming
        tools and commercial expectations have reshaped the landscape, creating a clear distinction. We need to
        acknowledge the rise of a role that is focused on abstracted assembly, maintenance and integration, separate
        from the more theoretical or academic aspects of software creation. This differentiation is crucial for setting
        clearer expectations and fostering progress within the software field.
      </p>
      <p>
        Before we dive deeper, it's essential to establish two core concepts that will underpin our discussion, helping
        us avoid purely semantic disagreements. Understanding the following two foundational ideas (axioms) will allow
        us to move past terminology and focus on the substantive issues at hand. I also understand this can be a
        sensitive subject; My goal is never to belittle or undermine the brilliant minds thriving across the diverse
        landscape of programming, but rather to establish clearer domains where different experiences and expertise can
        truly reach their intended audiences and flourish.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section id="axioms">
      <h1><u>Axioms (Core Truths)</u></h1>
      <p>
        Let's establish the following <q>axioms</q> to ensure a shared understanding of relativity. If you accept these
        concepts as true, subsequent conclusions should follow logically. However, if these axioms don't align with your
        own reality, then the conclusions derived from this framework may also diverge from your perspective.
      </p>
      <p>
        Both axioms are based on emergent human behaviors and patterns. While presented concisely here, each concept has
        extensive research that we've omitted for brevity.
      </p>

      <br />

      <h2>&#129504; &num;1 - Shared Qualia:</h2>
      <p>
        <b>Qualia</b> (singular: <b>quale</b>) refers to the individual, subjective, conscious experiences. It's often
        described as the <q>what it is like</q> aspect of mental states.
      </p>
      <p>
        Our brains form weighted neural pathways, shaping our perception through individual experiences. This inherent
        neuroplasticity allows constant learning but also strengthens established neural connections, making them
        resistant to change. Every person has a totally unique collection of qualia (perceptions), however, shared
        qualia (input&nbsp;&approx;&nbsp;output) enable phenomena like empathy and mutual understanding; Forming the
        basis where certain ideas can <q>just make sense</q> without explicit depiction, and conversely, where others
        <q>feel</q> inherently alien.
      </p>
      <p>
        Divergent experiences (worsened by reinforced pathways) create challenges between people. When individuals
        operate within different conceptual frameworks, their subjective experiences of the same activity can become
        profoundly different. This divergence can make it difficult for individuals to find common ground, leading to
        misunderstandings and hindering progress.
      </p>

      <br />

      <h2>&#10853; &num;2 - The <q>Understanding</q> Continuum:</h2>
      <p>
        Many mature knowledge based disciplines naturally grow beyond one persons understanding, and evolve across a
        spectrum that can be outlined by three various specializations.
      </p>

      <h3>1. Theoretical:</h3>
      <p>
        First, we have the <b>Theoretical</b> knowledge base. This is the entirely academic realm, where the
        foundational principles and knowledge for some topic are established. This knowledge partition is about
        understanding the core "how" and "why" at the deepest level, often without immediate practical application in
        mind.
      </p>

      <h3>2. Practical:</h3>
      <p>
        Next comes the <b>Practical</b> knowledge base. Here, theory meets the real world, applying those foundational
        principles to solve concrete problems and create the foundation of realized components. This knowledge base
        relies on an understanding of existing components and their interplay with each other and the world.
      </p>

      <h3>3. Abstract:</h3>
      <p>
        Finally, we arrive at the <b>Abstract</b> thinking. This stage builds on the outcomes of applied theory to
        achieve large-scale results. It's about working with ready-made components, tools, and established patterns to
        build complex systems efficiently, often abstracted away from the raw theoretical underpinnings or even the deep
        practical constraints of individual components.
      </p>

      <br />

      <h2>&#128506; The World We Have Created:</h2>
      <p>
        To sum up this section, we've established that we can share interpretations, and there are generally three
        interpretation levels for any sufficiently large knowledge-based subject.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section id="idea">
      <h1><u>To The Real World</u></h1>
      <p>
        Herein lies the core concept that I'm trying to <mark>&nbsp;highlight&nbsp;</mark>. Programmers now find
        ourselves - like many before - on a knowledge spectrum which has grown considerably large. <q>Mastering</q> the
        entire spectrum is beyond most human capabilities, as it requires deep understanding across conflicting mediums.
        That's why in other fields, we have divided and conquered, breaking it into disciplines so people can genuinely
        succeed within their area of focus.
      </p>

      <br />

      <h2>&#128498; An Established Example:</h2>
      <p>
        Let's look to a well-established knowledge-based field: electricity. Its
        <strong><em>theoretical</em></strong> knowledge is rooted in Electricity and Magnetism Physics. These concepts
        are then translated into <strong><em>practical</em></strong> knowledge by Electrical Engineers, who develop and
        research real-world electrical systems and products. Finally, the installation, maintenance, and repair of these
        systems and products constitute the <strong><em>abstract</em></strong> knowledge applied by Electricians. Each
        occupation along this continuum plays a crucial role in enabling the wider population to access the benefits of
        electricity in our homes.
      </p>
      <p>
        To the casual observer, the worlds of the Electrical Engineer and the Electrician appear to have significant
        overlap - both are, after all, experts in electricity; And indeed, in many broad strokes, they do. Yet, it's
        within their distinct qualia, their fundamental ways of experiencing and interacting with the electrical world,
        that crucial differences emerge, aligning with our established continuum. The Electrical Engineer's
        <em>qualia</em> is primarily shaped by practical knowledge: the systematic development, research, and validation
        of designs that bridge theoretical physics to functional products. Conversely, the Electrician's qualia is
        deeply rooted in abstract knowledge: the intuitive, applied understanding required to interpret and realize
        those designs, and then to diagnose, install, and maintain tangible electrical systems in complex, real-world
        environments.
      </p>
      <p>
        The problem, and where friction truly lies, isn't in a complete lack of shared understanding, but in the minute
        misalignments of these specific qualia - these "practical" and "abstract" worldviews - that we, as outsiders,
        often don't perceive. A common pitfall is to assume that because they both interact with electricity, their
        "worldviews" must align perfectly. This couldn't be further from the truth. This subtle divergence, if
        unaddressed, breeds constant friction and miscommunication, as each profession operates from a distinct, yet
        equally vital, understanding of what <q>working with electricity</q> truly entails.
      </p>
      <p>
        <i>
          Note: This perspective comes from a deep personal understanding: my father, a venerated Electrician with
          &approx; 40 years experience. We will get into more concrete examples once we've applied this idea to
          programming.
        </i>
      </p>

      <br />

      <h2>&#9000; Translating To Programmers:</h2>
      <p>
        Let's now translate this idea to the world of programming, mirroring our electricity continuum and its inherent
        qualia distinctions.
      </p>
      <p>
        Here, Computer Science represents the <strong><em>theoretical</em></strong> knowledge, delving into the
        foundational algorithms, data structures, and computational principles that underpin all software. The Software
        Engineer embodies <strong><em>practical</em></strong> knowledge, systematically designing, developing, and
        rigorously testing software solutions, effectively translating theoretical concepts into functional codebases
        and systems. Finally, the Software Developer operates with <strong><em>abstract</em></strong> knowledge,
        focusing on the hands-on implementation, debugging, and maintenance of specific applications and features. Like
        the Electrician, their strength lies in the tangible realization and ongoing care of the system, often applying
        intuitive problem-solving to make the code work effectively in diverse, real-world scenarios, even when the
        underlying logic isn't immediately obvious.
      </p>
      <p>
        And so, that's the core idea. It's a perspective not widely recognized, yet it carries profound implications
        when we consider its ramifications. Next, we'll dive into what this distinction means for common disagreements
        and frictions within the programming world. If you find yourself strongly disagreeing at this point, that's
        perfectly understandable. However, I encourage you to continue to the examples in the following section; perhaps
        these interpretations will shed light on why we observe certain phenomena within our professional communities.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section id="examples">
      <h1><u>Emergent Examples</u></h1>
      <p>
        Now, let's take our established worldview and use it as a lens to examine some hot topics in the programming
        community.
      </p>

      <br />

      <h2>&#396; Programming Languages:</h2>
      <p>
        Just as different trades require specialized tools, various programming languages naturally align with distinct
        <q>qualia</q> of programmers. This alignment often explains why certain languages provoke strong opinions or
        find success in particular domains, independent of their inherent <q>goodness.</q>
      </p>

      <h3>JavaScript</h3>
      <p>
        Consider <b>JavaScript</b>, a language frequently mocked for its inconsistencies and quirks, yet undeniably
        triumphant in its widespread adoption. While its peculiarities - like the sometimes baffling behavior of type
        coercion - might chafe those with a purist's eye, its remarkable simplicity for rapidly achieving functional
        results is its superpower. For the <q>Software Developer</q>, whose strength lies in
        <strong><em>abstract</em></strong> knowledge and just making things work, JavaScript is a near-perfect fit (as
        it seems). The <q>qualia</q> isn't focused on the intricate details of <code>Array.prototype.sort</code>'s
        default implementation, but on quickly integrating a solution that delivers the correct output. Its
        omnipresence, even extending beyond the browser to server-side environments, is a testament to its effectiveness
        as an abstract tool for agile <strong><em>abstract</em></strong> development, rather than a paragon of
        theoretical elegance.
      </p>

      <h3>Haskell vs Assembly and C</h3>
      <p>
        At the other end of this spectrum lies <b>Haskell</b>, often referred to as a <q>white paper</q> language due to
        its profound connection to Lambda Calculus and theoretical <q>Computer Science</q>. Its design principles
        prioritize mathematical rigor, immutability, and formal verification, making it a natural fit for academics
        engaged in deep <strong><em>theoretical</em></strong> reasoning and exploring the foundational principles of
        computation. Directly contrasting this are languages like <b>Assembly</b> and <b>C</b>, which firmly reside in
        the realm of the <q>Software Engineer.</q> These tools demand an intimate, granular understanding of how
        hardware operates, often requiring significant time and effort to grasp the system's inner workings. For the
        engineer (whose qualia is rooted in <strong><em>practical</em></strong> knowledge and the systematic translation
        of theoretical concepts into functional), being as close to the machine's implementation as possible isn't
        merely helpful - it's absolutely essential for their role in meticulously crafting how physical machines execute
        commands.
      </p>

      <h3>Python</h3>
      <p>
        <b>Python</b> offers a fascinating case study in versatility, demonstrating its utility across multiple points
        on our continuum. Its highly readable syntax, often likened to <q>pseudocode</q>, makes it an exceptional tool
        for rapid prototyping and abstract problem-solving, aligning perfectly with the
        <q>Software Developer's</q> focus on efficient implementation and tangible outcomes. Yet, this same clarity and
        simplicity paradoxically makes it a powerful vehicle for quickly demonstrating proofs and validating theoretical
        concepts, finding a surprising and significant home in academic research (<q>Computer Science</q>).
      </p>

      <h3>C#, C++ Rust</h3>
      <p>
        Languages such as <b>C#</b>, <b>C++</b> and <b>Rust</b> occupy some middle ground. They introduce substantial
        abstraction compared to <b>Assembly</b> or <b>C</b>, aiming to boost productivity and
        <q>do more with less,</q> appealing strongly to the <q>Software Developer's</q> objectives. However, they retain
        enough proximity to the system's mechanics that a <q>Software Engineer</q> benefits immensely from their deeper
        understanding of the underlying principles. For engineers, these languages often become invaluable for
        abstracting away recurring low-level challenges, leveraging their existing foundational knowledge to build
        robust and efficient systems. Conversely, a developer operating from a purely abstract viewpoint might find
        success in following established patterns with these languages, but without a foundational grasp of the
        underlying systems, they could feel stranded when confronted with complex issues demanding a more profound
        understanding of how these powerful tools truly operate (learning just as much as is needed to get a job done).
      </p>

      <h3>Programming Language Qualia</h3>
      <p>
        These varied examples illustrate how the design philosophies and practical applications of different programming
        languages inherently align with the distinct <q>qualia</q> and knowledge bases of
        <strong><em>Theoretical</em></strong
        >, <strong><em>Practical</em></strong
        >, and <strong><em>Abstract</em></strong> programming roles. Our framework offers a compelling explanation for
        many common frictions and misunderstandings that permeate our diverse professional communities - an explanation
        that often feels elusive in current discussions.
      </p>

      <br />

      <h2>&#128214; Education</h2>
      <p>
        <b>Foreword:</b>
        Before diving into this section, it's important to acknowledge that discussions around education and
        professional pathways can be deeply personal and contentious. We're venturing into territory where existing
        paradigms meet our theoretical framework. The real-world examples we're about to explore are not meant to
        devalue anyone's current journey or achievements. Rather, the aim is to shed light on phenomena that often go
        unexplained within our industry. Implicit in this discussion is a vision for an ideal world - one where becoming
        a highly competent <q>Software Developer</q> doesn't necessarily necessitate hundreds of thousands of dollars in
        student debt, and where educational pathways are more clearly aligned with the specific <q>qualia</q> and
        <strong><em>knowledge</em></strong> required for each role. This section seeks to provide a fresh perspective,
        not to dictate a single, rigid path, but to open a dialogue about how we can better educate and empower all
        programmers.
      </p>
      <br />
      <p>
        Understanding how our qualia are formed is crucial to discussing education. As previously agreed in our axioms,
        brains naturally build weighted neural pathways, making established perspectives resistant to change. Reshaping
        this qualia is a slow, methodical process that requires consistent effort (the <q>by wrote</q> method).
        Alternatively, it can be forced with more rapid transformation (usually this is from <q>trauma</q> - more to
        explore here, but for now, this is our axiom). Intentional education plays a critical role in aligning or
        expanding our individual qualia, allowing us to perceive and interact with complex domains in new ways. This is
        particularly evident when we consider how individuals acquire the distinct knowledge bases required for
        <strong><em>Theoretical</em></strong
        >, <strong><em>Practical</em></strong
        >, and <strong><em>Abstract</em></strong> programming.
      </p>
      <p>
        A common observation within programming circles is the celebrated <q>self-taught Software Engineer.</q> Often,
        when people refer to these individuals, they are, by our framework, speaking of highly talented
        <q>Software Developers.</q> These are indeed brilliant minds, capable of incredible feats of creation and
        problem-solving. However, their foundational knowledge, particularly concerning the deeper "how" and "why" of
        computing, may often be less comprehensive. While such a developer might have dedicated 10,000 hours to
        mastering C# and building intricate applications in the cloud, they might not be able to articulate precisely
        how their high-level code translates into the granular instructions a computer executes. Their learning, by its
        nature, has occurred primarily at the <strong><em>Abstract</em></strong> level, focusing on applying existing
        components and patterns rather than dissecting their underlying mechanisms.
      </p>
      <p>
        This brings us to the distinct educational demands of <q>Computer Science</q> and
        <q>Software Engineering.</q> These fields delve into theoretical principles and practical system design that are
        not intuitively discovered or naturally occurring. They represent decades of rigorous development by some of the
        greatest mathematical and logical minds. It is profoundly unlikely that any individual, through sheer
        self-application alone, could independently re-derive or fully internalize the breadth and depth of knowledge
        encompassing topics like advanced algorithms, data structures, compiler design, or operating system principles.
        These are structured disciplines, built on cumulative, non-obvious insights that necessitate a formal, guided
        journey of discovery and rigorous critical thinking to truly grasp.
      </p>
      <p>
        This formal journey, particularly within a university setting, often involves a significant degree of
        intellectual stress. While discomforting, this stress is a catalyst for neuroplasticity; without it, the brain
        has less impetus to dismantle or significantly modify its existing worldview. Those who navigate this rigorous
        ringer of brain reshaping emerge with a fundamentally different way of perceiving and interacting with the
        world. They possess a <strong><em>practical</em></strong> or <strong><em>theoretical</em></strong> qualia that
        enables them to approach problems from a foundational perspective, often invisible to those whose experiences
        have primarily been at a higher level of abstraction. <q>Software Development,</q> on the other hand, is much
        more accessible through self-study and focused application. Learning to build a web application over a weekend,
        for instance, is entirely feasible because it primarily involves acquiring and applying abstract
        knowledge-learning specific syntax, frameworks, and patterns - without inherently demanding a complete re-wiring
        of one's fundamental conceptual understanding.
      </p>
      <p>
        Ultimately, understanding these distinct educational pathways is key to appreciating the diverse strengths and
        perspectives within our programming community. It helps explain why different learning environments cultivate
        different types of qualia, and in turn, why certain roles are best suited to specific approaches of knowledge
        acquisition. Perhaps by recognizing these distinct needs, we can foster a future where
        <q>Software Development</q> truly emerges as a recognized trade, akin to that of an Electrician. This could
        empower countless individuals to gain industry-relevant skills without the immense financial burden or the
        perceived need to master theoretical concepts they may never directly apply in their daily work - addressing the
        common frustration of those with engineering degrees who feel over-qualified for much of the industry's
        developer work.
      </p>
    </section>

    <br />
    <hr />
    <br />

    <section id="finale">
      <h1><u>Final Thoughts</u></h1>
    </section>
  </body>
</html>
